# NESTCODER

You are NestCoder, a HTMX, EJS and TypeScript/NestJS language coding assistant.

## INPUT: 

You will receive a TARGET <FILE/> in the EJS or TypeScript/NestJS language, some additional <FILE/>'s for context, and a change or refactor <REQUEST/>, from the user.

## OUTPUT:

You must answer with one or more <FILE/> tags, including files to be overwritten, in order to fulfill the user's request.

---

# EXAMPLE NESTCODER USAGE

## Suppose you're given the following INPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/_.ts">
// A polymorphic List with two constructors:
// - Cons: appends an element to a list
// - Nil: the empty list
export type List<A>
  = { "$": "Cons", head: A, tail: List<A> }
  | { "$": "Nil" };
</FILE>

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts" TARGET>
// The map function for List, to be implemented
import { List } from "./_";

export function map<A, B>(fn: (a: A) => B, list: List<A>): List<B> {
  ?
}
</FILE>

<REQUEST>
complete the map function
</REQUEST>

## Then, you must answer with the following OUTPUT:

<FILE path="/Users/v/vic/dev/tsbook/List/map.ts">
import { List } from "./_";

// Applies a function to each element of a list.
// - fn: the function to be applied
// - xs: the elements to apply fn to
// = a new list with fn applied to all elements
export function map<A, B>(xs: List<A>, fn: (a: A) => B): List<B> {
  switch (xs.$) {
    case "Cons": {
      var head = fn(xs.head);
      var tail = map(xs.tail, fn);
      return { $: "Cons", head, tail };
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
</FILE>

(Because it fulfills the user's request perfectly.)

---

# GUIDE FOR THE TYPESCRIPT LANGUAGE

- Your code must be inspired by pure functional programming languages like Haskell.

- Every file must declare only, and only one, top-level function or datatype.

- Functions must be pure, using switch instead of 'if-else' or 'case-of'.

- When defining local variables, align equal signs whenever possible.

- Use CamelCase for everything. (IMPORTANT)

- A 'Foo/Bar' top-level definition must be either on './Foo/Bar.ts' or './Foo/Bar/_.ts'. 

# GUIDE FOR THE EJS LANGUAGE

- Use HTMX for frontend.

## Top-Level Function

Every .ts file must define ONE top-level function. Example:

```typescript
// Calculates the size of an HTerm
// - term: the HTerm to measure
// = the number of nodes in the term
export function size(term: HTerm): number {
  switch (term.$) {
    case "Lam": {
      var bod_size = size(term.bod({$: "Var", nam: term.nam}));
      return 1 + bod_size;
    }
    case "App": {
      var fun_size = size(term.fun);
      var arg_size = size(term.arg);
      return 1 + fun_size + arg_size;
    }
    case "Var": {
      return 1;
    }
  }
}
```

Where:
- The function name is defined (e.g., 'size')
- Parameters are specified with their types (e.g., 'term: HTerm')
- The return type is specified (e.g., ': number')
- The function body uses a switch statement for pattern matching
- Local variables are used to make the code less horizontal

## Top-Level Datatype

Alternatively, a .ts file can also define a datatype (ADT). Example:

```typescript
// Represents a Higher-Order Abstract Syntax Term
// - Lam: lambda abstraction
// - App: function application
// - Var: variable
export type HTerm
  = { $: "Lam", bod: (x: HTerm) => HTerm }
  | { $: "App", fun: HTerm, arg: HTerm }
  | { $: "Var", nam: string }
```

ADTs must follow this convention:
- Constructors represented as objects
- The dollar-sign is used for the constructor name
- Other object fields are the constructor fields

## Idiomatic TypeScript Examples

Below are some additional idiomatic TypeScript in the purely functional style: 

### List/zip.ts

```typescript
import { List } from "./_";

// Combines two lists into a list of pairs
// - xs: the first input list
// - ys: the second input list
// = a new list of pairs, with length equal to the shorter input list
export function zip<A, B>(xs: List<A>, ys: List<B>): List<[A, B]> {
  switch (xs.$) {
    case "Cons": {
      switch (ys.$) {
        case "Cons": {
          var head = [xs.head, ys.head] as [A,B];
          var tail = zip(xs.tail, ys.tail);
          return { $: "Cons", head, tail };
        }
        case "Nil": {
          return { $: "Nil" };
        }
      }
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### List/filter.ts

```typescript
import { List } from "./_";

// Filters a list based on a predicate function
// - xs: the input list
// - pred: the predicate function to test each element
// = a new list containing only elements that satisfy the predicate
export function filter<A>(xs: List<A>, pred: (a: A) => boolean): List<A> {
  switch (xs.$) {
    case "Cons": {
      var head = xs.head;
      var tail = filter(xs.tail, pred);
      return pred(xs.head) ? { $: "Cons", head, tail } : tail;
    }
    case "Nil": {
      return { $: "Nil" };
    }
  }
}
```

### Tree/_.ts

```typescript
// Represents a binary tree
// - Node: an internal node with a value and two subtrees
// - Leaf: a leaf node (empty)
export type Tree<A>
  = { $: "Node", val: A, left: Tree<A>, right: Tree<A> }
  | { $: "Leaf" };
```

### Tree/sum.ts

```typescript
import { Tree } from "./_";

// Sums all values in a numeric tree
// - tree: the tree to sum
// = the sum of all values in the tree
export function sum(tree: Tree<number>): number {
  switch (tree.$) {
    case "Node": {
      var left  = sum(tree.left);
      var right = sum(tree.right);
      return tree.val + left + right;
    }
    case "Leaf": {
      return 0;
    }
  }
}
```

### V3/_.ts

```typescript
// Represents a 3D vector
export type V3
  = { $: "V3", x: number, y: number, z: number };
```

### V3/dot.ts

```typescript
import { V3 } from "./_";

// Calculates the dot product of two 3D vectors
// - a: the first vector
// - b: the second vector
// = the dot product of a and b
export function dot(a: V3, b: V3): number {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
```

---

# NOTES

- Make ONLY the changes necessary to correctly fulfill the user's REQUEST.

- Do NOT fix, remove, complete or alter any parts unrelated to the REQUEST.

- Pay attention to the user's style, and mimic it as close as possible.

- Pay attention to the TypeScript examples and mimic their style as a default.

- Consult TypeScript guide to emit idiomatic correct code.

- Do NOT use or assume the existence of files that weren't shown to you.

- Be precise and careful in your modifications.

---

# TASK

You will now be given the actual INPUT you must work with.

<FILE path="/home/travis/Projects/runefort/src/lib/game-engine/BoardManager.ts">
import * as THREE from 'three';

export class BoardManager {
  private board: THREE.Group;
  private boardSize: number = 8;
  private squareSize: number = 1;

  constructor(private scene: THREE.Scene) {
    this.board = new THREE.Group();
  }

  createBoard(): void {
    const boardOffset = (this.boardSize * this.squareSize) / 2 - this.squareSize / 2;

    for (let x = 0; x < this.boardSize; x++) {
      for (let z = 0; z < this.boardSize; z++) {
        const geometry = new THREE.BoxGeometry(this.squareSize, 0.1, this.squareSize);
        const material = new THREE.MeshPhongMaterial({
          color: (x + z) % 2 === 0 ? 0xFFFFFF : 0x000000
        });
        const square = new THREE.Mesh(geometry, material);
        square.position.set(
          x * this.squareSize - boardOffset,
          0,
          z * this.squareSize - boardOffset
        );
        this.board.add(square);
      }
    }
    this.scene.add(this.board);
  }

  getBoard(): THREE.Group {
    return this.board;
  }
}
</FILE>
<FILE path="/home/travis/Projects/runefort/src/lib/game-engine/InputManager.ts">
import * as THREE from 'three';
import { CameraManager } from './CameraManager';
import { PlayerManager } from './PlayerManager';
import { BoardManager } from './BoardManager';

export class InputManager {
  private raycaster: THREE.Raycaster;
  private mouse: THREE.Vector2;

  constructor(
    private domElement: HTMLCanvasElement,
    private cameraManager: CameraManager,
    private playerManager: PlayerManager,
    private boardManager: BoardManager
  ) {
    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector2();

    this.domElement.addEventListener('click', (event) => this.onMouseClick(event), false);
    window.addEventListener('keydown', (event) => this.onKeyDown(event), false);
    window.addEventListener('wheel', (event) => this.onWheel(event), false);
  }

  private onMouseClick(event: MouseEvent): void {
    this.mouse.x = (event.clientX / this.domElement.clientWidth) * 2 - 1;
    this.mouse.y = -(event.clientY / this.domElement.clientHeight) * 2 + 1;

    this.raycaster.setFromCamera(this.mouse, this.cameraManager.getCamera());

    const intersects = this.raycaster.intersectObjects(this.boardManager.getBoard().children);

    if (intersects.length > 0) {
      const clickedSquare = intersects[0].object;
      this.playerManager.movePlayerToSquare(clickedSquare);
    }
  }

  private onKeyDown(event: KeyboardEvent): void {
    switch (event.key) {
      case 'a':
      case 'ArrowLeft':
        this.cameraManager.rotateCamera('left');
        break;
      case 'd':
      case 'ArrowRight':
        this.cameraManager.rotateCamera('right');
        break;
      case 'w':
      case 'ArrowUp':
        this.cameraManager.tiltCamera('up');
        break;
      case 's':
      case 'ArrowDown':
        this.cameraManager.tiltCamera('down');
        break;
    }
  }

  private onWheel(event: WheelEvent): void {
    const zoomFactor = 0.01; // Reduced zoom factor for more gradual zooming
    this.cameraManager.zoom(event.deltaY * zoomFactor);
  }
}
</FILE>
<FILE path="/home/travis/Projects/runefort/src/lib/game-engine/GameEngine.ts">
import * as THREE from 'three';
import { BoardManager } from './BoardManager';
import { PlayerManager } from './PlayerManager';
import { CameraManager } from './CameraManager';
import { InputManager } from './InputManager';

export class GameEngine {
  private scene: THREE.Scene;
  private renderer: THREE.WebGLRenderer;
  private boardManager: BoardManager;
  private playerManager: PlayerManager;
  private cameraManager: CameraManager;
  private inputManager: InputManager;

  constructor(container: HTMLElement) {
    this.scene = new THREE.Scene();
    this.renderer = new THREE.WebGLRenderer();
    this.renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(this.renderer.domElement);

    this.boardManager = new BoardManager(this.scene);
    this.playerManager = new PlayerManager(this.scene);
    this.cameraManager = new CameraManager(container.clientWidth / container.clientHeight);
    this.inputManager = new InputManager(this.renderer.domElement, this.cameraManager, this.playerManager, this.boardManager);

    this.init();

    window.addEventListener('resize', () => this.onWindowResize(container), false);
  }

  private init(): void {
    this.boardManager.createBoard();
    this.playerManager.createPlayer();
    this.addLighting();
    this.animate();
  }

  private addLighting(): void {
    const ambientLight = new THREE.AmbientLight(0x404040);
    this.scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(1, 1, 1);
    this.scene.add(directionalLight);
  }

  private animate(): void {
    requestAnimationFrame(() => this.animate());
    this.playerManager.update();
    this.cameraManager.updateCameraPosition(this.playerManager.getPlayerPosition());
    this.renderer.render(this.scene, this.cameraManager.getCamera());
  }

  private onWindowResize(container: HTMLElement): void {
    this.cameraManager.updateAspect(container.clientWidth / container.clientHeight);
    this.renderer.setSize(container.clientWidth, container.clientHeight);
  }
}
</FILE>
<FILE path="/home/travis/Projects/runefort/src/lib/game-engine/CameraManager.ts">
import * as THREE from 'three';

export class CameraManager {
  private camera: THREE.PerspectiveCamera;
  private cameraDistance: number = 10;
  private cameraRotation: number = 0;
  private cameraTilt: number = Math.PI / 4; // Initial tilt angle

  constructor(aspect: number) {
    this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
  }

  updateCameraPosition(playerPosition: THREE.Vector3): void {
    const cameraOffset = new THREE.Vector3(
      Math.sin(this.cameraRotation) * Math.sin(this.cameraTilt) * this.cameraDistance,
      Math.cos(this.cameraTilt) * this.cameraDistance,
      Math.cos(this.cameraRotation) * Math.sin(this.cameraTilt) * this.cameraDistance
    );
    this.camera.position.copy(playerPosition).add(cameraOffset);
    this.camera.lookAt(playerPosition);
  }

  updateAspect(aspect: number): void {
    this.camera.aspect = aspect;
    this.camera.updateProjectionMatrix();
  }

  getCamera(): THREE.PerspectiveCamera {
    return this.camera;
  }

  rotateCamera(direction: 'left' | 'right'): void {
    const rotationSpeed = 0.1;
    this.cameraRotation += direction === 'left' ? rotationSpeed : -rotationSpeed;
  }

  tiltCamera(direction: 'up' | 'down'): void {
    const tiltSpeed = 0.05;
    if (direction === 'up') {
      this.cameraTilt = Math.max(0.1, this.cameraTilt - tiltSpeed);
    } else {
      this.cameraTilt = Math.min(Math.PI / 2, this.cameraTilt + tiltSpeed);
    }
  }

  zoom(delta: number): void {
    this.cameraDistance += delta;
    this.cameraDistance = Math.max(2, Math.min(30, this.cameraDistance)); // Adjusted zoom range
  }
}
</FILE>
<FILE path="/home/travis/Projects/runefort/src/lib/renderer.ts">
import { GameEngine } from './game-engine/GameEngine';

const container = document.getElementById('game-container');
if (container) {
  console.log('found container')
  const game = new GameEngine(container);
}
</FILE>
<FILE path="/home/travis/Projects/runefort/src/renderer.ts">
/**
 * This file will automatically be loaded by webpack and run in the "renderer" context.
 * To learn more about the differences between the "main" and the "renderer" context in
 * Electron, visit:
 *
 * https://electronjs.org/docs/latest/tutorial/process-model
 *
 * By default, Node.js integration in this file is disabled. When enabling Node.js integration
 * in a renderer process, please be aware of potential security implications. You can read
 * more about security risks here:
 *
 * https://electronjs.org/docs/tutorial/security
 *
 * To enable Node.js integration in this file, open up `main.js` and enable the `nodeIntegration`
 * flag:
 *
 * ```
 *  // Create the browser window.
 *  mainWindow = new BrowserWindow({
 *    width: 800,
 *    height: 600,
 *    webPreferences: {
 *      nodeIntegration: true
 *    }
 *  });
 * ```
 */

import './index.css';

console.log('ðŸ‘‹ This message is being logged by "renderer.js", included via webpack');

import "./lib/renderer.ts"
</FILE>
<FILE path="src/lib/game-engine/PlayerManager.ts" TARGET>
import * as THREE from 'three';

export class PlayerManager {
  private player: THREE.Group;
  private body: THREE.Mesh;
  private head: THREE.Mesh;
  private leftArm: THREE.Mesh;
  private rightArm: THREE.Mesh;
  private leftLeg: THREE.Mesh;
  private rightLeg: THREE.Mesh;
  private walkAnimation: number = 0;

  constructor(private scene: THREE.Scene) {}

  createPlayer(): void {
    this.player = new THREE.Group();

    // Body
    const bodyGeometry = new THREE.BoxGeometry(0.5, 0.75, 0.25);
    const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x00FF00 });
    this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    this.player.add(this.body);

    // Head
    const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
    const headMaterial = new THREE.MeshPhongMaterial({ color: 0xFFCC99 });
    this.head = new THREE.Mesh(headGeometry, headMaterial);
    this.head.position.set(0, 0.625, 0);
    this.player.add(this.head);

    // Arms
    const armGeometry = new THREE.BoxGeometry(0.125, 0.5, 0.125);
    const armMaterial = new THREE.MeshPhongMaterial({ color: 0x00FF00 });
    this.leftArm = new THREE.Mesh(armGeometry, armMaterial);
    this.leftArm.position.set(0.3125, 0.125, 0);
    this.player.add(this.leftArm);

    this.rightArm = new THREE.Mesh(armGeometry, armMaterial);
    this.rightArm.position.set(-0.3125, 0.125, 0);
    this.player.add(this.rightArm);

    // Legs
    const legGeometry = new THREE.BoxGeometry(0.125, 0.5, 0.125);
    const legMaterial = new THREE.MeshPhongMaterial({ color: 0x0000FF });
    this.leftLeg = new THREE.Mesh(legGeometry, legMaterial);
    this.leftLeg.position.set(0.125, -0.625, 0);
    this.player.add(this.leftLeg);

    this.rightLeg = new THREE.Mesh(legGeometry, legMaterial);
    this.rightLeg.position.set(-0.125, -0.625, 0);
    this.player.add(this.rightLeg);

    this.player.position.set(0, 0.85, 0);
    this.scene.add(this.player);
  }
  
  getPlayerPosition(): THREE.Vector3 {
    return this.player.position;
  }

  movePlayerToSquare(square: THREE.Object3D): void {
    const targetPosition = new THREE.Vector3(square.position.x, 0.5, square.position.z);
    const currentPosition = this.player.position;
    
    // Check if the target square is adjacent (including diagonals)
    const dx = Math.abs(targetPosition.x - currentPosition.x);
    const dz = Math.abs(targetPosition.z - currentPosition.z);
    
    if (dx <= 1 && dz <= 1 && (dx + dz > 0)) {
      const distance = currentPosition.distanceTo(targetPosition);
      
      if (distance > 0.1) {
        const direction = targetPosition.sub(currentPosition).normalize();
        this.player.position.add(direction.multiplyScalar(0.1));
        this.player.lookAt(targetPosition);
        this.animateWalk();
      } else {
        this.player.position.copy(targetPosition);
        this.resetPose();
      }
    }
  }

  private animateWalk(): void {
    this.walkAnimation += 0.2;
    const swingAngle = Math.sin(this.walkAnimation) * 0.5;

    this.leftArm.rotation.x = -swingAngle;
    this.rightArm.rotation.x = swingAngle;
    this.leftLeg.rotation.x = swingAngle;
    this.rightLeg.rotation.x = -swingAngle;
  }

  private resetPose(): void {
    this.leftArm.rotation.x = 0;
    this.rightArm.rotation.x = 0;
    this.leftLeg.rotation.x = 0;
    this.rightLeg.rotation.x = 0;
  }

  update(): void {
    // This method should be called in the game loop to update player animations
  }
}
</FILE>
<REQUEST>
squares should be highlightable clickable. player should move to square when clicked.
</REQUEST>